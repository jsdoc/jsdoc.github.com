<!--{
    "title":       "@memberof",
    "out":         "tags-memberof.html",
    "description": "This object is a member or another object."
}-->
<h3>Syntax</h3>
<code>@memberof &lt;parentNamepath&gt;<br />
@memberof! &lt;parentNamepath&gt;</code>

<h3>Overview</h3>

<p>The @memberof tag marks a doclet as a member of another object.
</p>

<p>
With the @memberof tag, the member is documented as static.
If you want to document a member as belonging to an instance or prototype, use "@memberof parentNamepath#" or "@memberof parentNamepath.prototype" (see the examples).
Alternatively, use the <a href="tags-inner.html">@inner</a> or <a href="tags-instance.html">@instance</a> tags.
</p>

<p>
The "forced" memberof tag, @memberof!, forces the object to be documented as belonging to parentNamepath even if it is nested deeper. See the examples.
</p>

<h3>Examples</h3>

{{#example}}Using @memberof (basic use).
/** @namespace */
var Tools = {};

/** @memberof Tools */
var hammer = function() {
}

Tools.hammer = hammer;
{{/example}}
<p>Without the @memberOf tag, the <code>hammer</code> function would be documented as a global function.
That's because, in fact, it is a global function, but it is also a member of the <code>Tools</code> namespace as well, and that's how you wish to document it.
</p>

{{#example}}@memberof a class prototype sets the scope to instance.
/** @class Observable */
create(
    'Observable',
    {
        /** This will be a static member Observable.cache.
         * @memberof Observable */
        cache: [],

        /** This will be an instance member Observable#publish.
         * @memberof Observable.prototype */
        publish: function(msg) {},

        /** This will also be an instance member Observable#save.
         * @memberof Observable# */
        save: function() {}
    }
);
{{/example}}
<p>As mentioned before, @memberof causes the scope to be static.
To mark a member as belonging to a prototype or instance, use <code>@memberof ClassName.prototype</code> or <code>@memberof ClassName#</code>.
Alternatively, we could have used "@memberof Observable" with "@instance".
</p>

{{#example}} Using @memberof! [someOtherObject].
 /** @class */
 function Data() {
     /** @type {object}
         @property {number} y This will show up as a property of Data#point but won't be linkable. */
     this.point = {
         /** This forces this member to have name `point.x` (rather than `x`)
             and also to be a memberof Data#. This means {@link Data#point.x}
             will work.
             @name point.x
             @memberof! Data#
         */
         x: 0,
         y: 1
     };
 }
{{/example}}
<p>In the above example we use the forced memberof tag "@memberof!" to document a property of an object that is a member of a class.
Note that the Data#point has properties x and y.
</p>

<p>Usually one would document these in the way that y is documented, using <code>@property {number} y &lt;description&gt;</code> in the Data#point doclet.
However, y will <em>not</em> be linkable using <code>{@link Data#point.y}</code> in this way.
</p>

<p>We can force this to be linkable by pretending that Data#point.y is a member "point.y" of "Data#", rather than a member "y" of "point" of "Data#".
This is demonstrated in Data#point.x.
To achieve this, we force Data#point.x to have name "point.x" and be a member of "Data#".
</p>

<p>We have to use "@memberof!" rather than "@memberof", because otherwise JSDoc will get confused with the nested name "point.x" and try to document x as belonging to Data#point rather than Data#. Hence linking won't work for the same reason that Data#point.y didn't in the example above.
</p>

{{#example}}Using @memberof! <global>.
var map = {
    /**
        @type {Array}
        @name map.routes
        @memberof! <global>
     */
    routes: []
}
{{/example}}
<p>The forced memberof tag can also be used with special parent path "&lt;global&gt;" to mark an object as being global even if it has a nested-type name.
In the above example, <code>map.routes</code> is a global object. 
If we just used "@memberof" instead of "@memberof!", JSDoc would have tried to document object <code>routes</code> in object <code>map</code> which is global, but since <code>map</code> is not documented <code>map.routes</code> wouldn't appear in the output. We also have to force the doclet's name to be "map.routes", or else it would show up with name "routes".
</p>

{{#example}}Using @memberof instead of @name.
/** @namespace */
var MyNamespace = {};

/** @memberof MyNamespace */
var bar;
MyNamespace.bar = bar;

/** We could have just written the following instead to create MyNamespace.bar:
 * @name MyNamespace.bar */
{{/example}}

<p>In the above example, first we use @memberof to mark <code>bar</code> as a member of <code>MyNamespace</code>, i.e. <code>MyNamespace.bar</code>. However, we could also have just written <code>@name MyNamespace.bar</code> which achieves the same thing.

<h3>See Also</h3>

<ul>
    <li><a href="tags-name.html">@name</a></li>
</ul>
